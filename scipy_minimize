from scipy.optimize import minimize
from functools import partial

xab = [0.08, 0.04, 0.24, 0.04,
       0.36, 0.06, 0.06, 0.12]

def p_index(x, a, b):
  return 4*x + 2*a + b

def q_index(x, a, a_s, b):
  return 8*x + 4*a + 2*a_s + b

def q_a_s(vars, a_s):
  # Q(A# = a_s)
  q = 0
  for x in range(2):
    for a in range(2):
      for b in range(2):
        q += vars[q_index(x, a, a_s, b)]
  return q

def q_a_s_b(vars, a_s, b):
  # Q(A# = a_s, B = b)
  q = 0
  for x in range(2):
    for a in range(2):
      q += vars[q_index(x, a, a_s, b)]
  return q

def q_b_given_a_s(vars, a_s, b):
  # Q(B = b | A# = a_s) = Q(A# = a_s, B = b) / Q(A# = a_s)
  if q_a_s(vars, a_s) == 0:
    return 0
  return q_a_s_b(vars, a_s, b) / q_a_s(vars, a_s)

def q_x_a_s_b(vars, x, a_s, b):
  # Q(X = x, A# = a_s, B = b)
  q = 0
  for a in range(2):
    q += vars[q_index(x, a, a_s, b)]
  return q

def q_x_a_s(vars, x, a_s):
  # Q(X = x, A# = a_s)
  q = 0
  for a in range(2):
    for b in range(2):
      q += vars[q_index(x, a, a_s, b)]
  return q

def q_b_given_x_a_s(vars, x, a_s, b):
  # Q(B = b | X = x, A# = a_s) = Q(X = x, A# = a_s, B = b) / Q(X = x, A# = a_s)
  if q_x_a_s(vars, x, a_s) == 0:
    return 0
  return q_x_a_s_b(vars, x, a_s, b) / q_x_a_s(vars, x, a_s)

def q_a_b_a_s(vars, a, a_s, b):
  # Q(A = a, A# = a_s, B = b)
  q = 0
  for x in range(2):
    q += vars[q_index(x, a, a_s, b)]
  return q

def q_a_b_given_a_s(vars, a, b, a_s):
  # Q(A = a, B = b | A# = a_s) = Q(A# = a_s, A = a, B = b) / Q(A# = a_s)
  if q_a_s(vars, a_s) == 0:
    return 0
  return q_a_b_a_s(vars, a, a_s, b) / q_a_s(vars, a_s)

def d_separation(vars, x, a_s, b):
  # Q(B = b | X = x, A# = a_s) = Q(B = b | A# = a_s)
  return q_b_given_x_a_s(vars, x, a_s, b) - q_b_given_a_s(vars, a_s, b)

def consistency(vars, x, a, b):
  # P(X = x, A = a, B = b) = Q(X = x, A = a, A# = a, B = b)
  return xab[p_index(x, a, b)] - vars[q_index(x, a, a, b)]

def normalization(vars, a_s):
  # Q(A# = a_s) = 1
  return q_a_s(vars, a_s) - 1

def objective(vars):
  # minimize Q(B = 1 | A# = 1)
  return q_b_given_a_s(vars, 1, 1)

def d_sep2(vars, a_s, b):
  return q_b_given_x_a_s(vars, 1, a_s, b) - q_b_given_x_a_s(vars, 0, a_s, b)

def d_sep2_constraint(a_s, b):
  return {'type':'eq', 'fun': partial(d_sep2, a_s=a_s, b=b)}

def d_separation_constraint(x, a_s, b):
  return {'type':'eq', 'fun': partial(d_separation, x=x, a_s=a_s, b=b)}

def consistency_constraint(x, a, b):
  return {'type':'eq', 'fun': partial(consistency, x=x, a=a, b=b)}

def normalization_constraint(a_s):
  return {'type':'eq', 'fun': partial(normalization, a_s=a_s)}

constraints = []
'''
for x in range(2):
  for a_s in range(2):
    for b in range(2):
      constraints.append(d_separation_constraint(1, a_s, b))'''

for a_s in range(2):
  for b in range(2):
    constraints.append(d_sep2_constraint(a_s, b))

for x in range(2):
  for a in range(2):
    for b in range(2):
      constraints.append(consistency_constraint(x, a, b))

for a_s in range(2):
  constraints.append(normalization_constraint(a_s))

initial = [0.1] * 16

bounds = [(0, 1)] * 16

result = minimize(objective, initial, method='trust-constr', constraints=constraints, bounds=bounds)

print()
print("Q(XAB|A#=0)         Q(XAB|A#=1)")
for i in range(4):
  for j in range(4):
    print(f'{result.x[i*4 + j]:.6f}', end="  ")
  print()
print()

print()
print("     Q(B=1|A#=1) â‰¥", result.fun)
print("      P(A=1,B=1) =", xab[3] + xab[7])
print(" Q(A=1,B=1|A#=1) =", q_a_b_given_a_s(result.x, 1, 1, 1))
print("         Q(A#=1) =", q_a_s(result.x, 1))
print("         Q(A#=0) =", q_a_s(result.x, 0))
