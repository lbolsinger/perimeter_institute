import random
import math
import statistics

def sigmoid(x):
    return 1 / (1 + math.exp(-x))

def prob_married(age):
    z = -6 + 0.12 * age
    return sigmoid(z)

def compute_risk(sex, age, marital_status, accidents, income):
    score = 0
    if sex == 'm':
        score += 0.5
    if age < 20:
        score += 1.0
    elif age < 40:
        score += 0.5
    elif age < 60:
        score += 0.2
    if marital_status == 'single':
        score += 0.5
    if 0 < accidents < 3:
        score += 1.0
    elif accidents >= 3:
        score += 1.5
    if income < 10000:
        score += 1.0
    elif income < 50000:
        score += 0.5
    return round(score, 1)

## since any clients with the same characteristics have the same score, the would also have the same premium
def compute_base_premium(score):
    L = 500
    k = 0.5
    x0 = 3
    lower = 150
    premium = lower + (L - lower) / (1 + math.exp(-k * (score - x0)))
    return round(premium, 2)  

def update_premium(premium, treatment_percent):
    return round(premium * (1 + treatment_percent), 2)

## probability of retention as a sigmoid function ranging from 0 to 1
## the input is a linear function of measurable variables + randomness
## "continuous" variables using z-score from mean rather than raw value
def retention_prob(x):
    z = (0.05 * (x[1] == 'f') +
         0.15 * (x[2] - average_age) / std_dev_age + 
         0.1 * (x[3] == 'married') +
         0.2 * (x[4] - average_accidents) / std_dev_accidents +
         0.15 * (x[5] - average_income) / std_dev_income +
         -0.25 * (x[7] - average_premium) / std_dev_premium +
         -0.1 * x[8])
    z += random.gauss(0, 0.3)
    return round(sigmoid(z), 3)

## some features are generalized into groups/buckets rather than exact values
def bucket_age(age):
    if age < 20:
        return '<20'
    elif age < 40:
        return '20-39'
    elif age < 60:
        return '40-59'
    else:
        return '60+'

def bucket_accidents(acc):
    if acc == 0:
        return 'low'
    elif acc < 3:
        return 'medium'
    else:
        return 'high'

def bucket_income(income):
    if income < 20000:
        return '<20k'
    elif income < 50000:
        return '20k-50k'
    elif income < 80000:
        return '50k-80k'
    else:
        return '80k+'

random.seed(42)
clients = []
n_per_year = 2000
years = [2020, 2021, 2022, 2023, 2024, 2025]

treatment_dict = {}

for year in years:
    for _ in range(n_per_year):
        sex = random.choice(['m', 'f'])
        age = random.randint(18, 70)
        marital_status = 'married' if random.random() < prob_married(age) else 'single'
        accidents = random.choices([0, 1, 2, 3, 4, 5], weights=[0.5, 0.2, 0.15, 0.1, 0.04, 0.01])[0]
        income = random.randint(10000, 100000)

        features_key = (
            sex,
            bucket_age(age),
            marital_status,
            bucket_accidents(accidents),
            bucket_income(income)
        )
        key = (year, features_key)

        ## ensures that in a given year, all clients with the same characteristics have the same treatment
        if key not in treatment_dict:
            treatment_dict[key] = random.choice([-0.1, 0, 0.1, 0.2])

        treatment = treatment_dict[key]
        risk = compute_risk(sex, age, marital_status, accidents, income)
        premium = compute_base_premium(risk)
        new_premium = update_premium(premium, treatment)

        clients.append([
            year, sex, age, marital_status, accidents, income,
            risk, premium, treatment,new_premium, 0, False
        ])

average_age = statistics.mean([client[2] for client in clients])
std_dev_age = statistics.stdev([client[2] for client in clients])

average_income = statistics.mean([client[5] for client in clients])
std_dev_income = statistics.stdev([client[5] for client in clients])

average_accidents = statistics.mean([client[4] for client in clients])
std_dev_accidents = statistics.stdev([client[4] for client in clients])

average_premium = statistics.mean([client[7] for client in clients])
std_dev_premium = statistics.stdev([client[7] for client in clients])

for client in clients:
    client[10] = retention_prob(client)
    client[11] = random.random() < client[10]
