import pandas as pd

df = pd.read_csv('clients.csv')

def bucket_age(age):
    if age is None:
        return None
    if age < 20:
        return '<20'
    elif age < 40:
        return '20-39'
    elif age < 60:
        return '40-59'
    else:
        return '60+'

def bucket_accidents(acc):
    if acc is None:
        return None
    if acc == 0:
        return 'low'
    elif acc < 3:
        return 'medium'
    else:
        return 'high'

def bucket_income(income):
    if income is None:
        return None
    if income < 20000:
        return '<20k'
    elif income < 50000:
        return '20k-50k'
    elif income < 80000:
        return '50k-80k'
    else:
        return '80k+'


def calculate_conditional_retention_probability(df, sex=None, age=None, marital_status=None, income=None, accidents=None, treatment=None):
    """
    Calculates the conditional probability of retention based on given characteristics and treatment.
    Uses bucketing internally for age, accidents, and income if provided as raw values.

    Args:
        df (pd.DataFrame): The DataFrame containing client data.
        sex (str, optional): The sex of the client ('m' or 'f'). Defaults to None (all sexes).
        age (int, optional): The age of the client. Will be bucketed internally. Defaults to None.
        marital_status (str, optional): The marital status ('single' or 'married'). Defaults to None (all statuses).
        income (int, optional): The income of the client. Will be bucketed internally. Defaults to None.
        accidents (int, optional): The number of accidents. Will be bucketed internally. Defaults to None.
        treatment (float, optional): The treatment applied. Defaults to None (all treatments).

    Returns:
        float: The conditional probability of retention. Returns NaN if no clients match the criteria.
    """
    filtered_df = df.copy()

    if sex is not None:
        filtered_df = filtered_df[filtered_df['sex'] == sex]
    if age is not None:
        filtered_df = filtered_df[filtered_df['age'].apply(bucket_age) == bucket_age(age)]
    if marital_status is not None:
        filtered_df = filtered_df[filtered_df['marital_status'] == marital_status]
    if income is not None:
        filtered_df = filtered_df[filtered_df['income'].apply(bucket_income) == bucket_income(income)]
    if accidents is not None:
        filtered_df = filtered_df[filtered_df['accidents'].apply(bucket_accidents) == bucket_accidents(accidents)]
    if treatment is not None:
        filtered_df = filtered_df[filtered_df['treatment'] == treatment]

    if filtered_df.empty:
        return float('nan')
    else:
        return filtered_df['retained'].mean()

def count_clients_in_bucket(df, sex=None, age=None, marital_status=None, income=None, accidents=None, treatment=None):
    """
    Counts the number of clients in the given bucket.

    Args:
        df (pd.DataFrame): The DataFrame containing client data.
    """
    filtered_df = df.copy()
    if sex is not None:
        filtered_df = filtered_df[filtered_df['sex'] == sex]
    if age is not None:
        filtered_df = filtered_df[filtered_df['age'].apply(bucket_age) == bucket_age(age)]
    if marital_status is not None:
        filtered_df = filtered_df[filtered_df['marital_status'] == marital_status]
    if income is not None:
        filtered_df = filtered_df[filtered_df['income'].apply(bucket_income) == bucket_income(income)]
    if accidents is not None:
        filtered_df = filtered_df[filtered_df['accidents'].apply(bucket_accidents) == bucket_accidents(accidents)]
    if treatment is not None:
        filtered_df = filtered_df[filtered_df['treatment'] == treatment]

    return len(filtered_df)

## probability of retention given feature

retention_by_sex = df.groupby('sex')['retained'].mean()
print(retention_by_sex, "\n")

retention_by_age = df.groupby(df['age'].apply(bucket_age))['retained'].mean()
age_bucket_order = ['<20', '20-39', '40-59', '60+']
retention_by_age = retention_by_age.reindex(age_bucket_order)
print(retention_by_age, "\n")

retention_by_marital_status = df.groupby('marital_status')['retained'].mean()
print(retention_by_marital_status, "\n")

retention_by_income = df.groupby(df['income'].apply(bucket_income))['retained'].mean()
income_bucket_order = ['<20k', '20k-50k', '50k-80k', '80k+']
retention_by_income = retention_by_income.reindex(income_bucket_order)
print(retention_by_income, "\n")

retention_by_accidents = df.groupby(df['accidents'].apply(bucket_accidents))['retained'].mean()
accident_bucket_order = ['low', 'medium', 'high']
retention_by_accidents = retention_by_accidents.reindex(accident_bucket_order)
print(retention_by_accidents, "\n")

## probability of retention given feature and treatment

pivot_table_sex_treatment = df.pivot_table(values='retained', index='sex', columns='treatment', aggfunc='mean')
print(pivot_table_sex_treatment, "\n")

pivot_table_age_treatment = df.pivot_table(values='retained', index=df['age'].apply(bucket_age), columns='treatment', aggfunc='mean')
age_bucket_order = ['<20', '20-39', '40-59', '60+']
pivot_table_age_treatment = pivot_table_age_treatment.reindex(age_bucket_order)
print(pivot_table_age_treatment, "\n")

pivot_table_marital_status_treatment = df.pivot_table(values='retained', index='marital_status', columns='treatment', aggfunc='mean')
print(pivot_table_marital_status_treatment, "\n")

pivot_table_accidents_treatment = df.pivot_table(values='retained', index=df['accidents'].apply(bucket_accidents), columns='treatment', aggfunc='mean')
accident_bucket_order = ['low', 'medium', 'high']
pivot_table_accidents_treatment = pivot_table_accidents_treatment.reindex(accident_bucket_order)
print(pivot_table_accidents_treatment, "\n")

pivot_table_income_treatment = df.pivot_table(values='retained', index=df['income'].apply(bucket_income), columns='treatment', aggfunc='mean')
income_bucket_order = ['<20k', '20k-50k', '50k-80k', '80k+']
pivot_table_income_treatment = pivot_table_income_treatment.reindex(income_bucket_order)
print(pivot_table_income_treatment, "\n")

## probability of retention given two features and treatment

def generate_two_feature_treatment_pivot_tables(df, features):
    """
    Generates and prints pivot tables for every combination of two features
    from a list, along with the 'treatment' feature.

    Args:
        df (pd.DataFrame): The DataFrame containing client data.
        features (list): A list of feature names to create combinations from.
    """
    for i in range(len(features)):
        for j in range(i + 1, len(features)):
            feature1 = features[i]
            feature2 = features[j]

            print(f"Conditional Probability of Retention by {feature1}, {feature2}, and Treatment:")

            index_list = []
            if feature1 == 'age':
                index_list.append(df['age'].apply(bucket_age))
            elif feature1 == 'accidents':
                 index_list.append(df['accidents'].apply(bucket_accidents))
            elif feature1 == 'income':
                 index_list.append(df['income'].apply(bucket_income))
            else:
                index_list.append(feature1)

            if feature2 == 'age':
                index_list.append(df['age'].apply(bucket_age))
            elif feature2 == 'accidents':
                 index_list.append(df['accidents'].apply(bucket_accidents))
            elif feature2 == 'income':
                 index_list.append(df['income'].apply(bucket_income))
            else:
                index_list.append(feature2)

            pivot_table = df.pivot_table(
                values='retained',
                index=index_list,
                columns='treatment',
                aggfunc='mean'
            )

            if 'age' in [feature1, feature2]:
                age_bucket_order = ['<20', '20-39', '40-59', '60+']
                age_level = None
                for level_name in pivot_table.index.names:
                    if level_name is not None and ('age' in level_name or level_name == df['age'].apply(bucket_age).name):
                        if all(item in age_bucket_order for item in pivot_table.index.get_level_values(level_name).unique()):
                            age_level = level_name
                            break

                if age_level is not None:
                    sort_levels = [age_level] + [level for level in pivot_table.index.names if level != age_level]
                    pivot_table = pivot_table.sort_index(level=sort_levels)
                    # Reindex the age level to enforce the specific order
                    pivot_table = pivot_table.reindex(index=age_bucket_order, level=age_level)


            display(pivot_table)
            print("\n" + "="*50 + "\n") 

features = ['sex', 'marital_status', 'age', 'income', 'accidents']

## probability of retention given every combination of features

TREATMENTS = [None, -0.1, 0, 0.1, 0.2]
SEX = [None, "f", "m"]
AGE = [None, 0, 20, 40, 60] # instances from each bucket based on premium buckets
MARITAL_STATUS = [None, "married", "single"]
INCOME = [None, 0, 20000, 50000, 80000]
ACCIDENTS = [None, 0, 1, 5]

outcomes = []
for treatment in TREATMENTS:
    for sex in SEX:
        for age in AGE:
            for marital_status in MARITAL_STATUS:
                for income in INCOME:
                    for accidents in ACCIDENTS:
                        retention = calculate_conditional_retention_probability(df, treatment=treatment, sex=sex, age=age, marital_status=marital_status, income=income, accidents=accidents)
                        num = count_clients_in_bucket(df, treatment=treatment, sex=sex, age=age, marital_status=marital_status, income=income, accidents=accidents)
                        outcomes.append([treatment, sex, age, marital_status, income, accidents, retention, num])

## filter possible features of analysis for a given client description

SUFFICIENT = 30

def estimate_retention_given_client(df, treatment, sex, age, marital_status, income, accidents):

    input_values = {
        'treatment': treatment,
        'sex': sex,
        'age': bucket_age(age),
        'marital_status': marital_status,
        'income': bucket_income(income),
        'accidents': bucket_accidents(accidents)
    }

    filter_columns = ['treatment', 'sex', 'age', 'marital_status', 'income', 'accidents']

    combination_filters = []
    for treatment_val in ([input_values['treatment'], None]):
        for sex_val in ([input_values['sex'], None]):
            for age_val in ([input_values['age'], None]):
                for marital_status_val in ([input_values['marital_status'], None]):
                    for income_val in ([input_values['income'], None]):
                        for accidents_val in ([input_values['accidents'], None]):
                            combination_filters.append({
                                'treatment': treatment_val,
                                'sex': sex_val,
                                'age': age_val,
                                'marital_status': marital_status_val,
                                'income': income_val,
                                'accidents': accidents_val
                            })

    filtered_rows = pd.DataFrame()
    for criteria in combination_filters:
        current_filter = df.copy()
        for col in filter_columns:
            value = criteria[col]
            if value is not None:
                current_filter = current_filter[current_filter[col] == value]
            else:
                current_filter = current_filter[current_filter[col].isna()]

        filtered_rows = pd.concat([filtered_rows, current_filter])

    filtered_rows = filtered_rows.drop_duplicates().reset_index(drop=True)

    return filtered_rows

def filter_insufficient(df, treatment, sex, age, marital_status, income, accidents):
    result = estimate_retention_given_client(df, treatment, sex, age, marital_status, income, accidents)
    for row in result.itertuples():
        if row.number_of_clients < SUFFICIENT:
            result = result.drop(row.Index)
    return result

def filter_nan(df, treatment, sex, age, marital_status, income, accidents):
    result = filter_insufficient(df, treatment, sex, age, marital_status, income, accidents)
    vars = []
    for row in result.itertuples():
        row_vars = []
        if not pd.isna(row.treatment):
            row_vars.append('treatment')
        if not pd.isna(row.sex):
            row_vars.append('sex')
        if not pd.isna(row.age):
            row_vars.append('age')
        if not pd.isna(row.marital_status):
            row_vars.append('marital_status')
        if not pd.isna(row.income):
            row_vars.append('income')
        if not pd.isna(row.accidents):
            row_vars.append('accidents')

        dominated = False
        i = 0
        while not dominated and i < len(vars):
            if set(row_vars) <= set(vars[i]):
                result = result.drop(row.Index)
                dominated = True
            i += 1
        if not dominated:
            vars.append(row_vars)
    return result
