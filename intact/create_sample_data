import random
import math
import csv
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import roc_auc_score

def sigmoid(x):
    return 1 / (1 + math.exp(-x))

def prob_married(age):
    z = -6 + 0.12 * age
    return sigmoid(z)

class Client:
    def __init__(self, sex, age, marital_status, accidents, income, year):
        self.sex = sex
        self.age = age
        self.marital_status = marital_status
        self.accidents = accidents
        self.income = income
        self.year = year
        self.score = self.compute_score()
        self.premium = self.compute_premium()
        self.treatment = 0  # to be assigned externally
        self.adjusted_premium = self.premium
        self.retained = False  # to be assigned externally

    def compute_score(self):
        score = 0
        if self.sex == 'm':
            score += 0.5
        if self.age < 20:
            score += 1.0
        elif self.age < 40:
            score += 0.5
        elif self.age < 60:
            score += 0.2
        if self.marital_status == 'single':
            score += 0.5
        if 0 < self.accidents < 3:
            score += 1.0
        elif self.accidents >= 3:
            score += 1.5
        if self.income < 10000:
            score += 1.0
        elif self.income < 50000:
            score += 0.5
        return round(score, 1)

    def compute_premium(self):
        L = 500
        k = 0.5
        x0 = 3
        lower = 150
        premium = lower + (L - lower) / (1 + math.exp(-k * (self.score - x0)))
        return round(premium, 2)

    def apply_treatment(self, treatment_percent):
        """Apply % change to premium, e.g., -0.1 for 10% discount"""
        self.treatment = treatment_percent
        self.adjusted_premium = round(self.premium * (1 + treatment_percent), 2)

    def compute_retention_prob(self):
        z = 0
        if self.sex == 'm':
            z -= 0.2
        if self.age < 25:
            z -= 0.6
        elif self.age < 40:
            z -= 0.4
        elif self.age > 60:
            z += 0.1
        if self.marital_status == 'married':
            z += 0.3
        if self.accidents == 0:
            z -= 0.5
        elif self.accidents >= 3:
            z += 0.6
        if self.income < 20000:
            z -= 0.8
        elif self.income > 80000:
            z += 0.2

        # Use adjusted premium after treatment
        z += 800 / self.adjusted_premium
        z -= 10 * self.treatment

        z += random.gauss(0, 0.3)
        return max(round(sigmoid(z)-0.1, 3), 0.01)


# Bucketing functions to group clients by characteristics for consistent treatment
def bucket_age(age):
    if age < 20:
        return '<20'
    elif age < 40:
        return '20-39'
    elif age < 60:
        return '40-59'
    else:
        return '60+'

def bucket_accidents(acc):
    if acc == 0:
        return 0
    elif acc < 3:
        return 1
    else:
        return 3

def bucket_income(income):
    if income < 20000:
        return '<20k'
    elif income < 50000:
        return '20k-50k'
    elif income < 80000:
        return '50k-80k'
    else:
        return '80k+'

random.seed(42)
clients = []
n_per_year = 2000
years = [2020, 2021, 2022, 2023, 2024, 2025]

treatment_dict = {}

for year in years:
    for _ in range(n_per_year):
        sex = random.choice(['m', 'f'])
        age = random.randint(18, 70)
        marital_status = 'married' if random.random() < prob_married(age) else 'single'
        accidents = random.choices([0, 1, 2, 3, 4, 5], weights=[0.5, 0.2, 0.15, 0.1, 0.04, 0.01])[0]
        income = random.randint(10000, 100000)

        client = Client(sex, age, marital_status, accidents, income, year)

        features_key = (
            sex,
            bucket_age(age),
            marital_status,
            bucket_accidents(accidents),
            bucket_income(income)
        )
        key = (year, features_key)

        if key not in treatment_dict:
            treatment_dict[key] = random.choice([-0.1, 0, 0.1, 0.2])

        client.apply_treatment(treatment_dict[key])
        retention = client.compute_retention_prob()
        client.retained = random.random() < retention

        clients.append([
            year, sex, age, marital_status, accidents, income,
            client.score, client.premium, client.treatment, client.adjusted_premium, 
            retention, client.retained
        ])

with open("clients_with_treatment.csv", "w", newline='') as f:
    writer = csv.writer(f)
    writer.writerow([
        "year", "sex", "age", "marital_status", "accidents", "income",
        "score", "premium", "treatment", "adjusted_premium", "retention_prob", "retained"
    ])
    writer.writerows(clients)

print(f"CSV created with {len(clients)} clients â†’ 'clients_with_treatment.csv'")

# Extract adjusted premiums and retention probs for plots
adjusted_premiums = [row[9] for row in clients]
retention_probs = [row[10] for row in clients]

plt.figure(figsize=(10, 5))
plt.scatter(adjusted_premiums, retention_probs, alpha=0.2, s=10, color='blue')
plt.title('Retention Probability vs Adjusted Premium')
plt.xlabel('Adjusted Premium')
plt.ylabel('Retention Probability')
plt.grid(True)
plt.show()

plt.figure(figsize=(10, 5))
plt.hist(adjusted_premiums, bins=20, color='green', edgecolor='black', alpha=0.7)
plt.title('Histogram of Adjusted Premiums')
plt.xlabel('Adjusted Premium')
plt.ylabel('Number of Clients')
plt.grid(axis='y')
plt.show()

# Extract treatment groups and retention outcomes
treatments = [row[8] for row in clients]  # treatment
retained_flags = [row[11] for row in clients]  # retained (bool)

# Group retention by treatment
treatment_options = sorted(set(treatments))
avg_retention_by_treatment = []

for t in treatment_options:
    # Filter rows with treatment == t
    retained_for_t = [retained_flags[i] for i in range(len(clients)) if treatments[i] == t]
    avg_retention = np.mean(retained_for_t)  # mean True=1, False=0
    avg_retention_by_treatment.append(avg_retention)

# Plot
plt.figure(figsize=(8,5))
plt.bar([str(t) for t in treatment_options], avg_retention_by_treatment, color='skyblue')
plt.title('Average Retention Rate by Treatment')
plt.xlabel('Treatment (% Premium Change)')
plt.ylabel('Average Retention Rate')
plt.grid(axis='y')
plt.show()


## P(retention | characteristic, treatment)

df = pd.read_csv('clients_with_treatment.csv')
display(df.head())

p_r_given_s_t = df.groupby(['sex', 'treatment'])['retained'].mean().reset_index()
print("Probability of Retention by Sex and Treatment:")
display(p_r_given_s_t)

p_r_given_a_t = df.groupby(['age', 'treatment'])['retained'].mean().reset_index()
print("Probability of Retention by Age and Treatment:")
display(p_r_given_a_t.head()) 

p_r_given_ms_t = df.groupby(['marital_status', 'treatment'])['retained'].mean().reset_index()
print("\nProbability of Retention by Marital Status and Treatment:")
display(p_r_given_ms_t)

p_r_given_ac_t = df.groupby(['accidents', 'treatment'])['retained'].mean().reset_index()
print("\nProbability of Retention by Accidents and Treatment:")
display(p_r_given_ac_t)

p_r_given_i_t = df.groupby([df['income'].apply(bucket_income), 'treatment'])['retained'].mean().reset_index()
print("\nProbability of Retention by Income Bucket and Treatment:")
display(p_r_given_i_t)


## propensity scores by single characteristic

treatment_counts_by_sex = df.groupby(['sex', 'treatment']).size().reset_index(name='count')
sex_counts = df.groupby('sex').size().reset_index(name='total_count')
treatment_prob_by_sex = pd.merge(treatment_counts_by_sex, sex_counts, on='sex')
treatment_prob_by_sex['probability'] = treatment_prob_by_sex['count'] / treatment_prob_by_sex['total_count']
pivot_treatment_prob_by_sex = treatment_prob_by_sex.pivot(index='treatment', columns='sex', values='probability')
print("\nProbability of Treatment by Sex (pivoted):")
display(pivot_treatment_prob_by_sex)

treatment_counts_by_age = df.groupby([df['age'].apply(bucket_age), 'treatment']).size().reset_index(name='count')
age_counts = df.groupby(df['age'].apply(bucket_age)).size().reset_index(name='total_count')
treatment_prob_by_age = pd.merge(treatment_counts_by_age, age_counts, on='age')
treatment_prob_by_age['probability'] = treatment_prob_by_age['count'] / treatment_prob_by_age['total_count']
pivot_treatment_prob_by_age = treatment_prob_by_age.pivot(index='treatment', columns='age', values='probability')
print("\nProbability of Treatment by Age Group (pivoted):")
display(pivot_treatment_prob_by_age)

treatment_counts_by_marital = df.groupby(['marital_status', 'treatment']).size().reset_index(name='count')
marital_counts = df.groupby('marital_status').size().reset_index(name='total_count')
treatment_prob_by_marital = pd.merge(treatment_counts_by_marital, marital_counts, on='marital_status')
treatment_prob_by_marital['probability'] = treatment_prob_by_marital['count'] / treatment_prob_by_marital['total_count']
pivot_treatment_prob_by_marital = treatment_prob_by_marital.pivot(index='treatment', columns='marital_status', values='probability')
print("\nProbability of Treatment by Marital Status (pivoted):")
display(pivot_treatment_prob_by_marital)

treatment_counts_by_accidents = df.groupby(['accidents', 'treatment']).size().reset_index(name='count')
accidents_counts = df.groupby('accidents').size().reset_index(name='total_count')
treatment_prob_by_accidents = pd.merge(treatment_counts_by_accidents, accidents_counts, on='accidents')
treatment_prob_by_accidents['probability'] = treatment_prob_by_accidents['count'] / treatment_prob_by_accidents['total_count']
pivot_treatment_prob_by_accidents = treatment_prob_by_accidents.pivot(index='treatment', columns='accidents', values='probability')
print("\nProbability of Treatment by Accidents (pivoted):")
display(pivot_treatment_prob_by_accidents)

new_column_order = ['treatment', '<20k', '20k-50k', '50k-80k', '80k+']
treatment_counts_by_income = df.groupby([df['income'].apply(bucket_income), 'treatment']).size().reset_index(name='count')
income_counts = df.groupby(df['income'].apply(bucket_income)).size().reset_index(name='total_count')
treatment_prob_by_income = pd.merge(treatment_counts_by_income, income_counts, on='income')
treatment_prob_by_income['probability'] = treatment_prob_by_income['count'] / treatment_prob_by_income['total_count']
pivot_treatment_prob_by_income = treatment_prob_by_income.pivot(index='treatment', columns='income', values='probability')
print("\nProbability of Treatment by Income Bucket (pivoted):")
pivot_treatment_prob_by_income = pivot_treatment_prob_by_income.reindex(columns=new_column_order)
display(pivot_treatment_prob_by_income)


## Weights for linear regression model of retention given observable features

# Define features (X) and target (y)
X = df[["age", "sex", "marital_status", "accidents", "income", "treatment", "adjusted_premium"]].copy()
y = df["retained"]

# Encode 'sex' column
X['sex'] = X['sex'].map({'f': 0, 'm': 1})

# Encode 'marital_status' column
X['marital_status'] = X['marital_status'].map({'single': 0, 'married': 1})

# Split data into training and testing sets (optional but good practice)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Initialize and train the Logistic Regression model
retention_model = LogisticRegression()
retention_model.fit(X_train, y_train)

# Predict retention probabilities on the test set
retention_probs = retention_model.predict_proba(X_test)[:, 1] # Get probability of the positive class (retained = True)

# Evaluate the model (optional) - using AUC as an example
auc_score = roc_auc_score(y_test, retention_probs)
print(f"AUC Score for the Retention Model: {auc_score:.4f}")

print("\nLogistic Regression Model for Retention Probability trained successfully.")
# You can now use the 'retention_model' to predict retention probability for new clients.

# Get the coefficients and feature names from the trained model
coefficients = retention_model.coef_[0]
feature_names = X_train.columns

# Create a dictionary of features and their coefficients
coef_dict = dict(zip(feature_names, coefficients))

# Sort coefficients for better visualization
sorted_coef = sorted(coef_dict.items(), key=lambda item: item[1], reverse=True)

# Separate features and coefficients for plotting
features = [item[0] for item in sorted_coef]
weights = [item[1] for item in sorted_coef]

# Create a bar plot of the coefficients
plt.figure(figsize=(10, 6))
plt.bar(features, weights, color='skyblue')
plt.xlabel('Features')
plt.ylabel('Coefficient Value')
plt.title('Logistic Regression Model Coefficients (Weight of Factors)')
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()
